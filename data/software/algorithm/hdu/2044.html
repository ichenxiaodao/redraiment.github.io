<div title="2044 一只小蜜蜂..." class="article-content">
<div class="sign">2008-06-11 20:04</div>
<h1>问题描述</h1>
<h2>Problem Description</h2>
<p>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。其中，蜂房的结构如下所示。</p>
<img src="resources/figure/hdu/2044-1.jpg" />
<h2>Input</h2>
<p>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。</p>
<h2>Output</h2>
<p>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。</p>
<h2>Sample Input</h2>
<pre>2
1 2
3 6</pre>
<h2>Sample Output</h2>
<pre>1
3</pre>
<h1>问题分析</h1>
<h2>Problem Analyse</h2>
<p>递推题</p>
<h2>Algorithm Analyse</h2>
<img src="resources/figure/hdu/2044-2.jpg" align="right" />
<p>刚开始我看不懂这一题，因为我不清楚对于六边形的蜂房来说，哪一边算右边。</p>
<p>后来明白了，原来它所谓的右，是那张图的右边。</p>
<p>一只蜜蜂可以往下一格走，也可以往图的右边走。</p>
<p>比如:</p>
<p>蜜蜂在1格里，它可以往2、3两格里爬。</p>
<p>蜜蜂在6格里，它可以往7、8两格里爬。</p>
<p>所以在第n格里蜜蜂可以爬到第n+1, n+2格子里。</p>
<p>因此，这又是一个斐波那契数。 </p>
<h1>算法实现</h1>
<p>记得要用64位整数哦。</p>
<h1>参考源码</h1>
<pre><code data-language="c">#include &lt;stdio.h&gt;

int main(void)
{
  int i, j, n;
  __int64 d[51] = {1, 1, 2,};

  for (i = 3; i &lt; 51; i++)
    d[i] = d[i-1] + d[i-2];
  scanf("%d", &n);
  while (n-- && scanf("%d%d", &i, &j) != EOF)
    printf("%I64d\n", i &gt; j ? 0 : d[j-i]);

  return 0;
}</code></pre>
</div>
<script type="text/javascript" language="JavaScript" src="/resources/js/article.js"></script>
