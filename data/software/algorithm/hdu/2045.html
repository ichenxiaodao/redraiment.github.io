<div title="2045 不容易系列之(3)——LELE的RPG难题" class="article-content">
<div class="sign">2008-06-11 20:04</div>
<h1>问题描述</h1>
<h2>Problem Description</h2>
<p>人称“AC女之杀手”的超级偶像LELE最近忽然玩起了深沉，这可急坏了众多“Cole”（LELE的粉丝,即"可乐"）,经过多方打探，某资深Cole终于知道了原因，原来，LELE最近研究起了著名的RPG难题:</p>
<p>有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.</p>
<p>以上就是著名的RPG难题.</p>
<p>如果你是Cole,我想你一定会想尽办法帮助LELE解决这个问题的;如果不是,看在众多漂亮的痛不欲生的Cole女的面子上,你也不会袖手旁观吧?</p>
<h2>Input</h2>
<p>输入数据包含多个测试实例,每个测试实例占一行,由一个整数N组成，(0&lt;n&lt;=50)。</p>
<h2>Output</h2>
<p>对于每个测试实例，请输出全部的满足要求的涂法，每个实例的输出占一行。</p>
<h2>Sample Input</h2>
<pre>1
2</pre>
<h2>Sample Output</h2>
<pre>3
6</pre>
<h1>问题分析</h1>
<h2>Problem Analyse</h2>
<p>递推问题</p>
<h2>Algorithm Analyse</h2>
<p>数组F[i]保存i个方格有多少种填涂方法。</p>
<p>n个方格可以由n-1个方格和n-2个方格填充得到。</p>
<p>比如，在一涂好的n-1个格子里最后再插入一个格子，就得到了n个格子了。</p>
<p>因为已经填好n-1的格子中，每两个格子的颜色都不相同。</p>
<p>所以只能插入一种颜色。而n-1个格子一共有F[n-1]种填涂方法。所以从n-1格扩充到n格共有F(n-1)种方法。</p>
<p>若前n-1不合法，而添加一个后变成合法，即前n-2个合法，而第n-1个与第1个相同。这时候有两种填法。</p>
<pre>f[n] = f[n-1] + 2 * f[n-2];
f[1] = 3;
f[2] = 6;
f[3] = 6 </pre>
<h1>算法实现</h1>
<p>注意数据类型就可以了。</p>
<h1>参考源码</h1>
<pre><code data-language="c">#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
  int i;
  __int64 d[51] = {0, 3, 6, 6};

  for (i = 4; i &lt; 51; i++)
    d[i] = d[i-1] + 2*d[i-2];
  while (scanf("%d", &i) != EOF)
    printf("%I64d\n", d[i]);

  return 0;
}</code></pre>
</div>
<script type="text/javascript" language="JavaScript" src="/resources/js/article.js"></script>
